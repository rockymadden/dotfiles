function calc() {
  local result=$(printf "scale=10;$*\n" | bc --mathlib | tr -d '\\\n')

  if [[ "$result" == *.* ]]; then
    printf "$result" |
    sed -e 's/^\./0./' \
        -e 's/^-\./-0./' \
        -e 's/0*$//;s/\.$//'
  else
    printf "$result"
  fi

  printf "\n"
}

function cdf() {
  cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')"
}

function codepoint() {
  perl -e "use utf8; print sprintf('U+%04X', ord(\"$@\"))"

  if [ -t 1 ]; then
    echo ""
  fi
}

function curl() {
  local BIN=$(which curl)

  case "${1}" in
    finlink)
      ${BIN} "${2}" -s -L -I -o /dev/null -w "%{http_code}: %{url_effective}\\n"
    ;;

    follow)
      local resp=$(${BIN} "${2}" -s -I -o /dev/null -w "%{http_code}|%{redirect_url}")
      IFS='|' read -a tuple <<< "${resp}"

      echo "${tuple[0]}: ${2}"

      case "${tuple[0]}" in
        301|302|303|307|308)
          curl follow "${tuple[1]}"
        ;;
      esac
    ;;

    --binwrap)
      echo 'Usage:'
      echo '  curl {finlink|follow} <url>'
    ;;

    *)
      ${BIN} "${@:1}"
    ;;
  esac
}

function dataurl() {
  local mimeType=$(file -b --mime-type "$1")

  if [[ $mimeType == text/* ]]; then
    mimeType="${mimeType};charset=utf-8"
  fi

  echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')"
}

function digga() {
  dig +nocmd "$1" any +multiline +noall +answer
}

function docker() {
  local BIN=$(which docker)

  case "$1" in
    bash)
      ${BIN} exec -it "${2}" bash
    ;;

    daemonize)
      ${BIN} run -d -P "${@:2}"
    ;;

    flatten)
      ${BIN} export $(${BIN} run -d "${2}" /bin/bash) | ${BIN} import - "${3}"
    ;;

    interact)
      ${BIN} run -i -t -P "${@:2}"
    ;;

    ip)
      ${BIN} inspect -f '{{.NetworkSettings.IPAddress}}' "${2}"
    ;;

    mac)
      ${BIN} inspect -f '{{.NetworkSettings.MacAddress}}' "${2}"
    ;;

    ports)
      ${BIN} inspect -f '{{range $p, $conf := .NetworkSettings.Ports}} {{$p}} -> {{(index $conf 0).HostPort}} {{end}}' "${2}"
    ;;

    rmall)
      ps=$(${BIN} ps -a -q)
      [ -n "$ps" ] && docker stopall && ${BIN} rm "${@:2}" $ps
    ;;

    rmstopped)
      ps=$(${BIN} ps -a -q -f 'status=exited')
      [ -n "$ps" ] && ${BIN} rm "${@:2}" $ps
    ;;

    rmiall)
      images=$(${BIN} images -q)
      [ -n "$images" ] && docker stopall && docker rmall && ${BIN} rmi "${@:2}" $images
    ;;

    rmidangling)
      images=$(${BIN} images -q -f 'dangling=true')
      [ -n "$images" ] && ${BIN} rmi "${@:2}" $images
    ;;

    statsall)
      ${BIN} stats "${@:2}" $(${BIN} ps -q)
    ;;

    stopall)
      ps=$(${BIN} ps -a -q)
      [ -n "$ps" ] && ${BIN} stop "${@:2}" $ps
    ;;

    volumes)
      ${BIN} inspect -f '{{$conf := .Mounts}} {{(index $conf 0).Destination}} -> {{(index $conf 0).Source}}' "${2}"
    ;;

    --binwrap)
      echo 'Usage:'
      echo '  docker {rmall|rmstopped|rmiall|rmidangling|statsall|stopall}'
      echo '  docker bash <container>'
      echo '  docker daemonize <image> <command>'
      echo '  docker flatten <image> <new image>'
      echo '  docker interact <image> <command>'
      echo '  docker ip <container>'
      echo '  docker mac <container>'
      echo '  docker ports <container>'
      echo '  docker volumes <container>'
    ;;

    *)
      ${BIN} "${@:1}"
    ;;
  esac
}

# dotfile package manager manager
function dfpmm() {
  case "${1}" in
    init)
      case "${2}" in
        apms|apm-packages|atom-packages) mkdir -p ~/.atom/packages ;;

        brews|brew-forumulas|brew-packages)
          brew tap homebrew/dupes
          brew tap homebrew/science
          brew tap rockymadden/rockymadden
        ;;

        casks|brew-cask-formulas|brew-cask-packages)
          brew tap caskroom/cask
          brew tap caskroom/versions
        ;;

        gems|ruby-packages) return 0 ;;

        npms|node-packages) return 0 ;;

        pips|python-packages) return 0 ;;
      esac
    ;;

    install)
      case "${2}" in
        apms|apm-packages|atom-packages)
          local p=$(<~/.dfpmm-apm)
          local d=$(comm -13 <(apm list --bare --installed | ghead -n -1 | cut -f1 -d'@' | sort) <(echo "${p}" | sort))

          test -n "${d}" && read -p "Proceed with installing (y/n)? Packages: $(echo "${d}" | tr '\n' ' ')" proceed
          case "${proceed}" in
            y|Y) echo "${d}" | xargs apm install ;;
            *) return 1 ;;
          esac
        ;;

        brews|brew-forumulas|brew-packages)
          local p=$(<~/.dfpmm-brew)
          local d=$(comm -13 <(brew list -1 | sed 's|rockymadden/rockymadden/||' | sort) <(echo "${p}" | sort))

          test -n "${d}" && read -p "Proceed with installing (y/n)? Packages: $(echo "${d}" | tr '\n' ' ')" proceed
          case "${proceed}" in
            y|Y) brew update && echo "${d}" | xargs brew install ;;
            *) return 1 ;;
          esac
        ;;

        casks|brew-cask-formulas|brew-cask-packages)
          local p=$(<~/.dfpmm-brew-cask)
          local d=$(comm -13 <(brew cask list -1 | sort) <(echo "${p}" | sort))

          test -n "${d}" && read -p "Proceed with installing (y/n)? Packages: $(echo "${d}" | tr '\n' ' ')" proceed
          case "${proceed}" in
            y|Y) brew cask update && echo "${d}" | xargs brew cask install ;;
            *) return 1 ;;
          esac
        ;;

        gems|ruby-packages)
          local p=$(<~/.dfpmm-gem)

          test -n "${p}" && read -p "Proceed with installing (y/n)? Packages: $(echo "${p}" | tr '\n' ' ')" proceed
          case "${proceed}" in
            y|Y) echo "${p}" | xargs gem install ;;
            *) return 1 ;;
          esac
        ;;

        npms|node-packages)
          local p=$(<~/.dfpmm-npm)

          test -n "${p}" && read -p "Proceed with installing (y/n)? Packages: $(echo "${p}" | tr '\n' ' ')" proceed
          case "${proceed}" in
            y|Y) echo "${p}" | xargs npm install -g ;;
            *) return 1 ;;
          esac
        ;;

        pips|python-packages)
          local p=$(<~/.dfpmm-pip)

          test -n "${p}" && read -p "Proceed with installing (y/n)? Packages: $(echo "${p}" | tr '\n' ' ')" proceed
          case "${proceed}" in
            y|Y) echo "${p}" | xargs pip install ;;
            *) return 1 ;;
          esac
        ;;
      esac
    ;;

    uninstall)
      case "${2}" in
        apms|apm-packages|atom-packages)
          local p=$(<~/.dfpmm-apm)
          local d=$(comm -13 <(echo "${p}" | sort) <(apm list --bare --installed | ghead -n -1 | cut -f1 -d'@' | sort))

          test -n "${d}" && read -p "Proceed with uninstalling (y/n)? Packages: $(echo "${d}" | tr '\n' ' ')" proceed
          case "${proceed}" in
            y|Y) echo "${d}" | xargs apm uninstall ;;
            *) return 1 ;;
          esac
        ;;

        brews|brew-forumulas|brew-packages)
          local p=$(<~/.dfpmm-brew)
          local d=$(comm -13 <(echo "${p}" | sort) <(brew leaves | sed 's|rockymadden/rockymadden/||' | sort))

          test -n "${d}" && read -p "Proceed with uninstalling (y/n)? Packages: $(echo "${d}" | tr '\n' ' ')" proceed
          case "${proceed}" in
            y|Y) echo "${d}" | xargs brew uninstall ;;
            *) return 1 ;;
          esac
        ;;

        casks|brew-cask-formulas|brew-cask-packages)
          local p=$(<~/.dfpmm-brew-cask)
          local d=$(comm -13 <(echo "${p}" | sort) <(brew cask list -1 | sort))

          test -n "${d}" && read -p "Proceed with uninstalling (y/n)? Packages: $(echo "${d}" | tr '\n' ' ')" proceed
          case "${proceed}" in
            y|Y) echo "${d}" | xargs brew cask zap ;;
            *) return 1 ;;
          esac
        ;;

        gems|ruby-packages) return 0 ;;

        npms|node-packages) return 0 ;;

        pips|python-packages) return 0 ;;
      esac
    ;;

    *) echo 'Command not found' ; return 1 ;;
  esac
}

function escape() {
  printf "\\\x%s" $(printf "$@" | xxd -p -c1 -u)

  if [ -t 1 ]; then
    echo ""
  fi
}

function fs() {
  if du -b /dev/null > /dev/null 2>&1; then
    local arg=-sbh
  else
    local arg=-sh
  fi
  if [[ -n "$@" ]]; then
    du $arg -- "$@"
  else
    du $arg .[^.]* *
  fi
}

function mkd() {
  mkdir -p "$@" && cd "$_"
}

function slack() {
  case "${1}" in
    collaborator)
      local url=$(git browse -u)
      local repo=$(git browse -u | sed -e 's|https://github.com/||g')

      command slack send "*Collaborator state change:* ${2}" \
        --author="${repo}" \
        --author-icon='https://assets-cdn.github.com/images/modules/logos_page/Octocat.png' \
        --author-link="${url}" \
        --channel="${3}" \
        --color=good
    ;;

    pull-request)
      local url=$(git browse -u)
      local repo=$(git browse -u | sed -e 's|https://github.com/||g')
      local desc=$(git issue | grep "${2}" | cut -d ']' -f2)

      command slack send "*Pull request merged into master:* ${desc}" \
        --author="${repo}" \
        --author-icon='https://assets-cdn.github.com/images/modules/logos_page/Octocat.png' \
        --author-link="${url}" \
        --channel="${3}" \
        --color=good
    ;;

    *) command slack "${@:1}" ;;
  esac
}

function socat() {
  case "${1}" in
    http-echo|echo-http)
      local port=8080

      while (( "$#" )); do
        case "${2}" in
          --port=*) port=${2/--port=/''} ; shift ;;
          -p*) port=${3} ; shift ;;
          *) shift ;;
        esac
      done

      command socat -v -T0.05 tcp-listen:${port},reuseaddr,fork,crlf system:"source ~/.functions && socat _http-echo"
    ;;

    _http-echo|_echo-http)
      echo 'HTTP/1.1 200 OK'
      echo 'Content-Type: text/plain'
      echo "Date: $(date)"
      echo "Server: ${SOCAT_SOCKADDR}:${SOCAT_SOCKPORT}"
      echo "Client: ${SOCAT_PEERADDR}:${SOCAT_PEER_PORT}"
      echo 'Connection: close'
      echo
      cat
    ;;

    *) command socat "${@:1}" ;;
  esac
}

function ssh() {
  local BIN=$(which ssh)

  case "${1}" in
    forward)
      test "$#" -lt 2 && return 1

      a=(${2//:/ })

      case "$#" in
        3)
          lp=${3}
          rp=${a[1]}
        ;;
        2)
          lp=${a[1]}
          rp=${a[1]}
        ;;
      esac

      case "${a[0]}" in
        *@*) ${BIN} -N -L ${lp}:localhost:${rp} -l ${a[0]/@/ } & ;;
        *) ${BIN} -N -L ${lp}:localhost:${rp} -l $(whoami) ${a[0]} & ;;
      esac
    ;;

    --binwrap)
      echo 'Usage:'
      echo '  ssh forward [username]@<remote_host>:<remote_port> [local_port]'
    ;;

    *)
      ${BIN} "${@:1}"
    ;;
  esac
}

function tarbz2() {
  tar -cjf $1.tar.bz $1
}

function targz() {
  local tmpFile="${@%/}.tar"
  tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1

  size=$(
    stat -f"%z" "${tmpFile}" 2> /dev/null
    stat -c"%s" "${tmpFile}" 2> /dev/null
  )

  local cmd=""
  if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
    cmd="zopfli"
  else
    if hash pigz 2> /dev/null; then
      cmd="pigz"
    else
      cmd="gzip"
    fi
  fi

  echo "Compressing .tar using \`${cmd}\`..."
  "${cmd}" -v "${tmpFile}" || return 1
  [ -f "${tmpFile}" ] && rm "${tmpFile}"
  echo "${tmpFile}.gz created successfully."
}

function title() {
  echo -ne "\033]0;"$*"\007"
}

function unidecode() {
  perl -e "binmode(STDOUT, ':utf8'); print \"$@\""

  if [ -t 1 ]; then
    echo ""
  fi
}

function vegeta() {
  local BIN=$(which vegeta)

  case "$1" in
    GET)
      echo "GET ${2}" | vegeta attack -duration="${3}" -rate="${4}" | tee /tmp/vegeta.bin | vegeta report
    ;;

    --binwrap)
      echo 'Usage:'
      echo '  vegeta GET <url>'
    ;;

    *)
      ${BIN} "${@:1}"
    ;;
  esac
}


function wget() {
  local BIN=$(which wget)

  case "$1" in
    mirror)
      ${BIN} -mkpnp "${2}"
    ;;

    --binwrap)
      echo 'Usage:'
      echo '  wget mirror <baseurl>'
    ;;

    *)
      ${BIN} "${@:1}"
    ;;
  esac
}
